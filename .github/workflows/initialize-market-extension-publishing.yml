name: Initialize Market Extension Publishing

on: 
  workflow_dispatch:
    inputs:
      productName:
        description: |
          Product Name (as displayed as name on the website), i.e. check Axon Ivy Portal at https://market.axonivy.com/portal#tab-description
        required: true
      productType:
        description: 'Category â€“ choose between Connector (REST/SOAP connection), Utils (helper), or Demo (example process).'
        required: true
        type: choice
        options:
          - connector
          - utils
          - demo
      version:
        description: 'Ivy version used for development (choose latest 12.x or 13.x)'
        required: true
        type: choice
        options:
          - 12.x
          - 13.x

permissions:
  contents: write

jobs:
  initialize-market-extension:
    if: github.ref == 'refs/heads/master'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Java JDK
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: 21

      - name: Resolve latest engine version
        id: ivy
        run: |
          selected="${{ github.event.inputs.version }}"
          page=$(curl -s https://developer.axonivy.com/download)
          latest12=$(echo "$page" | grep -oE '12\.[0-9]+\.[0-9]+' | sort -V | tail -n 1)
          latest13=$(echo "$page" | grep -oE '13\.[0-9]+\.[0-9]+' | sort -V | tail -n 1)
          if [[ "$selected" == "12.x" ]]; then
            version="$latest12"
          else
            version="$latest13"
          fi
          engineUrl="https://developer.axonivy.com/permalink/${version}/axonivy-engine.zip"
          echo "version=$version" >> $GITHUB_OUTPUT
          echo "convert_to_version=$version" >> $GITHUB_OUTPUT
          echo "engineUrl=$engineUrl" >> $GITHUB_OUTPUT

      - name: Download and extract Axon Ivy Engine
        id: engine
        run: |
          mkdir -p "$RUNNER_TEMP/engine"
          echo "Downloading engine from ${{ steps.ivy.outputs.engineUrl }}"
          curl -sL -o "$RUNNER_TEMP/engine.zip" "${{ steps.ivy.outputs.engineUrl }}"
          unzip -q "$RUNNER_TEMP/engine.zip" -d "$RUNNER_TEMP/engine"
          rm "$RUNNER_TEMP/engine.zip"
          engineCli=$(find "$RUNNER_TEMP/engine" -type f -name EngineConfigCli | head -n 1)
          if [ -z "$engineCli" ]; then
            echo "EngineConfigCli not found"
            ls -R "$RUNNER_TEMP/engine"
            exit 1
          fi
          chmod +x "$engineCli" || true
          engineBinDir="$(dirname "$engineCli")"
          engineRoot="$(dirname "$engineBinDir")"
          echo "engineCli=$engineCli" >> $GITHUB_OUTPUT
          echo "engineBinDir=$engineBinDir" >> $GITHUB_OUTPUT
          echo "engineRoot=$engineRoot" >> $GITHUB_OUTPUT

      - name: Compute variables
        id: vars
        run: |
          productName="${{ github.event.inputs.productName }}"
          productType="${{ github.event.inputs.productType }}"

          lowercaseProductName=$(echo "$productName" | tr '[:upper:]' '[:lower:]' | sed 's/[ -]/./g')
          groupId="com.axonivy.$productType.$lowercaseProductName"
          displayedType="$(tr '[:lower:]' '[:upper:]' <<< ${productType:0:1})${productType:1}"
          displayName="$productName $displayedType"

          echo "productName=$productName" >> $GITHUB_OUTPUT
          echo "productType=$productType" >> $GITHUB_OUTPUT
          echo "groupId=$groupId" >> $GITHUB_OUTPUT
          echo "displayName=$displayName" >> $GITHUB_OUTPUT

      - name: Update placeholders in file contents
        run: |
          productName="${{ steps.vars.outputs.productName }}"
          groupId="${{ steps.vars.outputs.groupId }}"
          displayName="${{ steps.vars.outputs.displayName }}"
          version="${{ steps.ivy.outputs.version }}"
          repoName="${{ github.event.repository.name }}"

          find . -type f -not -path "./.git/*" -not -path "./.github/*" \
            -exec sed -i \
              -e "s|# MY-PRODUCT-NAME|# $displayName|g" \
              -e "s|# MEIN-PRODUKT-NAME|# $displayName|g" \
              -e "s|\"MY-PRODUCT-NAME\"|\"$repoName\"|g" \
              -e "s|MY-PRODUCT-NAME|$repoName|g" \
              -e "s|REPO-NAME|${repoName}|g" \
              -e "s|MY-GROUP-ID|$groupId|g" \
              -e "s|<groupId>com.axonivy.market</groupId>|<groupId>$groupId</groupId>|g" \
              -e "s|com\.axonivy\.market\.my\.product\.name|$groupId|g" \
              -e "s|<version>12.0.0-SNAPSHOT</version>|<version>$version-SNAPSHOT</version>|g" \
              -e "s|<project.build.plugin.version>.*</project.build.plugin.version>|<project.build.plugin.version>$version</project.build.plugin.version>|g" \
              -e "s|<tester.version>.*</tester.version>|<tester.version>$version</tester.version>|g" \
              {} +;

      - name: Replace placeholders in file and folder names
        run: |
          productName="${{ github.event.repository.name }}"
          # Traverse deepest paths first to avoid conflicts
          find . -depth -name "*MY-PRODUCT-NAME*" \
            -exec bash -c 'f="{}"; mv "$f" "$(dirname "$f")/$(basename "$f" | sed "s/MY-PRODUCT-NAME/'"$productName"'/g")"' \;

      # Generate Java-like folder structure for Ivy packages (src, src_hd, src_test, dataclasses)
      - name: Create package directory skeletons
        run: |
          set -euo pipefail
          groupId="${{ steps.vars.outputs.groupId }}"
          packagePath="${groupId//./\/}"
          echo "Preparing package skeleton for groupId=$groupId => $packagePath"

          shopt -s nullglob
          for pom in ./*/pom.xml; do
            moduleDir="${pom%/pom.xml}"
            moduleName="$(basename "$moduleDir")"

            # Skip any module ending with "-product" 
            if [[ "$moduleName" == *-product ]]; then
              echo "Skipping module $moduleName (product module)"
              continue
            fi

            # Source-type roots
            for root in src src_hd src_test; do
              if [ ! -d "$moduleDir/$root" ]; then
                if [ "$root" = "src" ]; then
                  echo "  + creating missing $root root"; mkdir -p "$moduleDir/$root"; else continue; fi
              fi
              target="$moduleDir/$root/$packagePath"
              if [ ! -d "$target" ]; then
                echo "  + mkdir -p $target"; mkdir -p "$target"; touch "$target/.gitkeep"; fi
            done
            # Dataclasses root (special for Ivy)
            if [ -d "$moduleDir/dataclasses" ]; then
              dcTarget="$moduleDir/dataclasses/$packagePath"
              if [ ! -d "$dcTarget" ]; then
                echo "  + mkdir -p $dcTarget"; mkdir -p "$dcTarget"; touch "$dcTarget/.gitkeep"; fi
            fi
          done

      - name: Raise Ivy project to desired version
        run: |
          set -euo pipefail
          engineBinDir="${{ steps.engine.outputs.engineBinDir }}"
          version="${{ steps.ivy.outputs.version }}"
          convert_to_version="${{ steps.ivy.outputs.convert_to_version }}"

          export IVY_JAVA_HOME="$JAVA_HOME"
          export PATH="$JAVA_HOME/bin:$PATH"

          projects=()
          while IFS= read -r -d '' pref; do
            projDir="$(dirname "$(dirname "$pref")")"
            # Validate Ivy Designer project markers
            [ -f "$projDir/pom.xml" ] || continue
            [ -f "$projDir/.project" ] || continue
            [ -d "$projDir/.settings" ] || continue
            projects+=("$(realpath "$projDir")")
          done < <(find . -type f -name 'ch.ivyteam.ivy.designer.prefs' -print0)

          if [ "${#projects[@]}" -eq 0 ]; then
            echo "No Ivy Designer projects found; skipping migration."
            exit 0
          fi

          mapfile -t projects < <(printf '%s\n' "${projects[@]}" | sort -u)
          (cd "$engineBinDir" && ./EngineConfigCli migrate-project "${projects[@]}")

      - name: Commit changes and clean up workflow
        if: success()
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          rm .github/workflows/initialize-market-extension-publishing.yml || true
          git add .
          git commit -m "Initialize new product: ${{ steps.vars.outputs.productName }} v${{ steps.ivy.outputs.version }}" || echo "No changes to commit"
          git push origin master